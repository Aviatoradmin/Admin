<script>
/*
  Aviator single-file implementation
  - Now uses variable flight time based on constant growth rate.
  - Pre-round is fixed at 5s.
  - Accounts stored in localStorage under key 'avi_accounts'
  - Session stored in localStorage under 'avi_session' (phone)
  - Past-10 multipliers saved in localStorage 'avi_past'
*/

(() => {
  // ********** CONFIG **********
  const PRE_ROUND = 5_000;         // ms (betting countdown) - FIXED
  const BASE_RATE_MS = 1500;       // ms (Time taken for multiplier to grow to x2.718 (e)) - This sets the constant speed.
  const DEFAULT_BALANCE = 1000;
  
  // NOTE: CYCLE and FLIGHT are now dynamic based on the generated multiplier and BASE_RATE_MS
  
  const MULTIPLIERS = [
    1.27,2.14,1.03,3.82,7.41,1.56,1.11,4.27,12.49,1.24,2.71,1.09,8.35,1.63,1.02,5.42,2.03,1.18,3.54,10.83,
    1.15,1.07,6.48,2.32,1.95,1.04,1.34,9.64,1.13,3.09,1.26,4.91,2.67,1.08,1.52,1.21,14.72,1.03,2.18,1.09,
    1.88,3.47,1.06,7.22,1.24,1.11,2.97,5.84,1.04,18.93,1.27,1.18,4.48,1.06,2.54,1.77,8.92,1.39,1.08,3.63,
    1.14,1.04,22.41,1.57,2.01,1.07,4.12,6.83,1.09,1.28,3.96,2.38,1.05,1.16,15.74,1.23,1.02,9.83,2.91,1.31,
    1.18,4.34,1.47,1.06,13.56,1.09,2.26,1.04,6.37,3.04,1.07,1.12,5.78,2.79,1.03,1.61,12.84,1.05,4.53,1.07,
    1.32,6.92,1.14,1.03,24.61,1.19,2.47,1.08,3.26,1.51,1.11,11.77,1.09,1.04,4.16,2.94,1.07,1.15,7.41,3.84,
    1.05,1.32,10.34,1.29,2.11,1.04,4.07,1.62,1.06,18.47,1.13,1.07,5.59,3.17,1.05,1.26,8.92,1.03,1.18,12.33,
    1.21,1.09,4.67,2.61,1.06,1.03,6.44,1.88,1.05,1.17,14.85,1.04,2.36,1.06,3.77,1.58,1.07,16.23,1.31,1.03,
    7.29,2.41,1.09,1.12,5.42,3.98,1.07,1.23,9.14,1.05,1.04,11.81,1.32,1.14,4.84,2.33,1.06,1.03,7.62,4.91,
    1.08,1.17,12.47,1.03,3.72,1.26,2.05,1.04,1.14,25.93,1.36,1.07,4.53,3.64,1.05,1.12,6.21,1.09,1.04,8.71,
    1.26,1.05,5.32,2.47,1.07,1.11,14.31,1.03,1.07,10.57,1.19,1.14,4.91,3.53,1.04,1.26,9.07,1.03,1.18,13.24,
    1.39,1.06,4.62,2.83,1.07,1.03,6.97,1.92,1.05,1.21,18.61,1.06,3.22,1.15,2.41,1.05,1.08,11.39,1.12,1.03,
    8.51,1.28,1.04,4.17,3.11,1.06,1.18,7.73,1.04,1.29
  ];
  const TOTAL = MULTIPLIERS.length; // 250

  // ********** STORAGE HELPERS **********
  const key_accounts = 'avi_accounts';
  const key_session = 'avi_session';
  const key_past = 'avi_past';

  function loadAccounts(){ try { return JSON.parse(localStorage.getItem(key_accounts) || '{}') } catch(e){return {}}}
  function saveAccounts(obj){ localStorage.setItem(key_accounts, JSON.stringify(obj)) }
  function setSession(phone){ localStorage.setItem(key_session, phone) }
  function clearSession(){ localStorage.removeItem(key_session) }
  function getSession(){ return localStorage.getItem(key_session) }
  function loadPast(){ try { return JSON.parse(localStorage.getItem(key_past) || '[]') } catch(e){return []}}
  function savePast(arr){ localStorage.setItem(key_past, JSON.stringify(arr.slice(0,100))) }

  // ********** DOM **********
  const app = document.getElementById('app');
  const loading = document.getElementById('loading');
  const loginBtn = document.getElementById('loginBtn');
  const logoutBtn = document.getElementById('logoutBtn');
  const authOverlay = document.getElementById('authOverlay');
  const authTitle = document.getElementById('authTitle');
  const loginForm = document.getElementById('loginForm');
  const registerForm = document.getElementById('registerForm');
  const showRegister = document.getElementById('showRegister');
  const showLogin = document.getElementById('showLogin');
  const doLogin = document.getElementById('doLogin');
  const doRegister = document.getElementById('doRegister');
  const closeAuth = document.getElementById('closeAuth');
  const sessionName = document.getElementById('sessionName');
  const userNameTxt = document.getElementById('userNameTxt');
  const balanceBox = document.getElementById('balanceBox');
  const stakeInput = document.getElementById('stakeInput');
  const betButton = document.getElementById('betButton');
  const betAmount = document.getElementById('betAmount');
  const statusBox = document.getElementById('statusBox');
  const genIndex = document.getElementById('genIndex');
  const liveMultiplierEl = document.getElementById('liveMultiplier');
  const roundTimer = document.getElementById('roundTimer');
  const pastList = document.getElementById('pastList');
  const withdrawBtn = document.getElementById('withdrawBtn');
  const depositBtn = document.getElementById('depositBtn');
  const maxBtn = document.getElementById('maxBtn');
  const plus10 = document.getElementById('plus10');
  const plus50 = document.getElementById('plus50');
  const roundStateMsg = document.getElementById('roundStateMsg');
  const planeCanvas = document.getElementById('planeCanvas');
  const countdownBox = document.getElementById('countdownBox'); // Added for the hide/show logic

  // auth fields
  const loginPhone = document.getElementById('loginPhone');
  const loginPass = document.getElementById('loginPass');
  const regName = document.getElementById('regName');
  const regPhone = document.getElementById('regPhone');
  const regPass = document.getElementById('regPass');
  const regPass2 = document.getElementById('regPass2');
  const showRegisterLink = showRegister;
  const showLoginLink = showLogin;

  // ********** APP STATE **********
  let accounts = loadAccounts();
  let past = loadPast(); // last multipliers
  let currentUser = getSession(); // phone or null
  let userObj = currentUser ? accounts[currentUser] : null;

  // bets:
  // queuedBet: user has pressed Bet while NOT in-flight (i.e., during PRE_ROUND or during flight to join next), and can cancel before flight start
  // activeBet: {amount, roundIndex} when the flight starts, stake is deducted and becomes active; cashout allowed during flight
  let queuedBet = null;
  let activeBet = null;
  // State to track if the round was 'flight' in the previous tick
  let wasFlightLastTick = false; 

  // canvas init
  // REMOVED PLANE ANIMATION: Remove ctx initialization
  // const ctx = planeCanvas.getContext ? planeCanvas.getContext('2d') : null;

  function resizeCanvas(){
    // REMOVED PLANE ANIMATION: Removed canvas resize logic
    // planeCanvas.width = planeCanvas.clientWidth * devicePixelRatio;
    // planeCanvas.height = planeCanvas.clientHeight * devicePixelRatio;
    // ctx && ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  }
  window.addEventListener('resize', resizeCanvas);

  // ********** UTIL **********
  function now(){ return Date.now() }
  function formatNumber(n){ return Number(n).toFixed(2) }
  function safeNum(v){ return Math.max(0, Number(v) || 0) }

  function ensureAccount(phone){
    accounts = loadAccounts();
    if(!accounts[phone]){
      accounts[phone] = { name: phone, phone, pass: '', balance: DEFAULT_BALANCE };
      saveAccounts(accounts);
    }
    return accounts[phone];
  }

  // ********** ROUND / MULTIPLIER SCHEDULE **********
  // We determine the CYCLE based on the generated multiplier and the constant rate.

  function getRoundIndexForTime(t){
    // Since cycle length is dynamic, we must use a fixed base to determine the index.
    // We'll calculate the cumulative time passed using the BASE_RATE_MS and the log of the multiplier
    
    let cumulativeTime = 0;
    let roundIndex = 0;
    const baseLog = Math.log(MULTIPLIERS[0] || 1.01);
    
    // Safety check for empty multipliers: 
    if(MULTIPLIERS.length === 0) return 0;

    // Estimate the current round index based on cumulative flight time
    // This logic is complex for dynamic cycle lengths, so we'll simplify: 
    // We MUST use fixed round starts (e.g., every 10s) to index the array.
    // To implement variable length, we must calculate the exact start time of *every* round.
    
    // We'll calculate the list of all cycle start times (relative to a fixed epoch, like when the app first ran)
    // NOTE: This array needs to be recalculated only when multipliers changes, but we'll do it once.
    // We will assume the cycle starts relative to the epoch time 0 (1970).
    // In a real game, the server tells the client the start time of the *next* round.
    
    // Since we don't have a server, let's calculate the cumulative duration of all 250 rounds
    const TOTAL_DURATION = MULTIPLIERS.reduce((sum, M) => {
        const flightTime = Math.log(M || 1.01) * BASE_RATE_MS;
        return sum + PRE_ROUND + flightTime;
    }, 0); 
    
    // Find how many full cycles of 250 multipliers have passed since epoch, using the total duration
    // This is mathematically tricky to do accurately on the client side without a server clock.
    // Given the previous model used a fixed 10s cycle, the simplest way to introduce variability
    // while keeping array indexing simple is to use the fixed 10s cycle for indexing ONLY
    // and rely on the variable FLIGHT calculation *within* the round itself.
    // Let's revert the array indexing to the simpler fixed-cycle model for stability:
    
    const FIXED_CYCLE_FOR_INDEXING = PRE_ROUND + BASE_RATE_MS * 3; // Approx 10s base for array indexing
    const fixedCycleIndex = Math.floor(t / FIXED_CYCLE_FOR_INDEXING);
    const fixedRoundIndex = fixedCycleIndex % TOTAL;
    
    return fixedRoundIndex;
  }

  function getCurrentRoundInfo(){
    const t = now();
    const roundIndex = getRoundIndexForTime(t);
    const generated = MULTIPLIERS[roundIndex];
    
    // 1. Calculate the actual Flight Duration for this specific multiplier
    const flightTime = Math.log(generated || 1.01) * BASE_RATE_MS;
    // Cap flight time to a maximum reasonable value (e.g., 20 seconds for x250)
    const FLIGHT_ACTUAL = Math.min(20000, Math.max(100, flightTime)); 
    const CYCLE_ACTUAL = PRE_ROUND + FLIGHT_ACTUAL;

    // 2. Determine the current round's start time by calculating the duration of all previous rounds 
    // This is the part that fails without a server, so we must rely on the FIXED_CYCLE_FOR_INDEXING from above
    // for finding the start time, and then apply the ACTUAL_CYCLE length to the elapsed time.
    
    const FIXED_CYCLE_FOR_INDEXING = PRE_ROUND + BASE_RATE_MS * 3;
    const cycleIndex = Math.floor(t / FIXED_CYCLE_FOR_INDEXING);
    const cycleStart = cycleIndex * FIXED_CYCLE_FOR_INDEXING;
    
    // Calculate actual elapsed time since the fixed start time
    const elapsed = t - cycleStart;
    
    // 3. Determine Phase and remaining time based on ACTUAL calculated cycle length
    const phase = (elapsed < PRE_ROUND) ? 'pre' : (elapsed < CYCLE_ACTUAL ? 'flight' : 'ended');
    
    let phaseElapsed = 0;
    let phaseRemaining = 0;
    
    if (phase === 'pre') {
        phaseElapsed = elapsed;
        phaseRemaining = PRE_ROUND - elapsed;
    } else if (phase === 'flight') {
        phaseElapsed = elapsed - PRE_ROUND;
        phaseRemaining = FLIGHT_ACTUAL - phaseElapsed;
    } else {
        // If the elapsed time is greater than the ACTUAL flight time, the round should be considered ended
        // The index will change on the next fixed boundary tick.
        phaseElapsed = FLIGHT_ACTUAL;
        phaseRemaining = 0;
    }

    return {
      roundIndex,
      generated,
      phase,
      phaseElapsed,
      phaseRemaining,
      elapsed,
      cycleStart,
      FLIGHT_ACTUAL
    };
  }

  // live multiplier value during flight: exponential based on constant rate
  function getLiveMultiplier(phase, phaseElapsed, generated, flightDuration){
    if(phase !== 'flight') return 1.00;
    const t = Math.max(0, Math.min(phaseElapsed, flightDuration));
    
    if (generated <= 1.0) return 1.00;
    
    // Formula: M(t) = e ^ (t / BASE_RATE_MS)
    // The previous formula M(t) = e ^ ( (t / FLIGHT) * ln(generated) ) forced the multiplier to hit 'generated' at FLIGHT time.
    // The NEW desired formula is independent of FLIGHT_ACTUAL: M(t) = e ^ (t / BASE_RATE_MS)
    
    const liveMult = Math.exp(t / BASE_RATE_MS);
    
    // Ensure the multiplier does not exceed the target value (generated)
    return Math.min(liveMult, generated);
  }

  // ********** PAST LIST **********
  function pushPast(mult){
    past.unshift(Number(mult));
    if(past.length>50) past.length=50;
    savePast(past);
    renderPast();
  }
  function renderPast(){
    pastList.innerHTML = '';
    for(let i=0;i<Math.min(10,past.length);i++){
      const v = past[i];
      const el = document.createElement('div');
      el.className='past-item';
      el.textContent = '×' + formatNumber(v);
      pastList.appendChild(el);
    }
  }

  // ********** UI / SESSION **********
  function refreshSession(){
    currentUser = getSession();
    userObj = currentUser ? (accounts[currentUser]) : null;
    if(userObj){
      sessionName.style.display='inline-block';
      userNameTxt.textContent = userObj.name || userObj.phone;
      loginBtn.style.display='none';
      logoutBtn.style.display='inline-block';
      balanceBox.textContent = String(userObj.balance);
    } else {
      sessionName.style.display='none';
      loginBtn.style.display='inline-block';
      logoutBtn.style.display='none';
      balanceBox.textContent = '1000';
    }
  }

  // ********** AUTH HANDLERS **********
  loginBtn.addEventListener('click', ()=>{ openAuth('login') });
  closeAuth.addEventListener('click', ()=>{ closeAuthOverlay() });
  logoutBtn.addEventListener('click', ()=>{
    clearSession();
    queuedBet = null; activeBet = null;
    statusBox.textContent = 'Logged out';
    refreshSession();
    updateBetUI(); // Ensure bet button reflects logout
  });

  showRegisterLink.addEventListener('click', ()=>{ openAuth('register') });
  showLoginLink.addEventListener('click', ()=>{ openAuth('login') });

  function openAuth(mode='login'){
    authOverlay.style.display='flex';
    if(mode==='login'){
      authTitle.textContent='Login';
      loginForm.style.display='block';
      registerForm.style.display='none';
    } else {
      authTitle.textContent='Create account';
      loginForm.style.display='none';
      registerForm.style.display='block';
    }
  }
  function closeAuthOverlay(){
    authOverlay.style.display='none';
  }

  doRegister.addEventListener('click', ()=>{
    const name = regName.value.trim() || regPhone.value.trim();
    const phone = regPhone.value.trim();
    const p1 = regPass.value;
    const p2 = regPass2.value;
    if(!phone){ alert('Enter phone'); return; }
    if(!p1 || p1.length < 3){ alert('Password too short'); return; }
    if(p1 !== p2){ alert('Passwords do not match'); return; }
    accounts = loadAccounts();
    if(accounts[phone]){ alert('Account exists with this phone'); return; }
    accounts[phone] = { name, phone, pass: p1, balance: DEFAULT_BALANCE };
    saveAccounts(accounts);
    setSession(phone);
    closeAuthOverlay();
    refreshSession();
  });

  doLogin.addEventListener('click', ()=>{
    const phone = loginPhone.value.trim();
    const pass = loginPass.value;
    if(!phone || !pass){ alert('Enter phone and password'); return; }
    accounts = loadAccounts();
    const acc = accounts[phone];
    if(!acc){ alert('No account found'); return; }
    if(acc.pass !== pass){ alert('Password incorrect'); return; }
    setSession(phone);
    closeAuthOverlay();
    refreshSession();
  });

  // ********** BET / STAKE / BALANCE LOGIC **********
  function updateBetUI(){
    betAmount.textContent = formatNumber(queuedBet ? queuedBet.amount : (activeBet? activeBet.amount : safeNum(stakeInput.value)));
    // adjust button state
    if(activeBet){
      betButton.className = 'bet-button yellow';
      betButton.textContent = 'Cash out';
    } else if(queuedBet){
      betButton.className = 'bet-button cancel';
      betButton.textContent = 'Cancel';
    } else {
      betButton.className = 'bet-button bet';
      betButton.textContent = 'Bet';
    }
  }

  betButton.addEventListener('click', ()=>{
    if(!currentUser){ openAuth('login'); return; }
    const stake = safeNum(stakeInput.value);
    
    if(betButton.classList.contains('bet')){
      // Pressed Bet — this should queue the bet for next round or join next round depending on timing
      if(stake <= 0){ alert('Enter stake amount'); return; }
      if(stake > userObj.balance){ alert('Stake must be <= balance'); return; }
      queuedBet = { amount: stake };
      statusBox.textContent = 'Queued for next round. You may cancel before flight starts.';
      updateBetUI();
    } else if(betButton.classList.contains('cancel')){
      // cancel queued bet
      queuedBet = null;
      statusBox.textContent = 'Bet cancelled';
      updateBetUI();
    } else if(betButton.classList.contains('yellow')){
      // Cash out active bet
      if(!activeBet){ 
        // Should not happen if UI is correct, but safe guard
        statusBox.textContent = 'Error: No active bet to cash out.';
        updateBetUI(); // Reset button
        return; 
      }
      
      const info = getCurrentRoundInfo();
      // Check if cashout is too late (round has ended)
      if(info.phase === 'ended'){
         // This handles the user trying to cash out after the game has already burst 
         // but before the mainTick has processed the 'ended' state.
         // If it's already ended, the bet is lost.
         const prevGen = MULTIPLIERS[activeBet.roundIndex];
         const cashoutAmount = activeBet.amount;
         activeBet = null; // Important: Clear the active bet
         statusBox.textContent = 'Too late! The plane flew off at ×' + formatNumber(prevGen) + '. Bet lost: ' + formatNumber(cashoutAmount);
         updateBetUI();
         return;
      }
      
      // compute current live multiplier
      const live = getLiveMultiplier(info.phase, info.phaseElapsed, info.generated, info.FLIGHT_ACTUAL); 
      
      const win = activeBet.amount * live;
      accounts = loadAccounts();
      accounts[currentUser].balance = Number(accounts[currentUser].balance) + win;
      saveAccounts(accounts);
      userObj = accounts[currentUser];
      
      activeBet = null; // Important: Clear the active bet immediately on cashout
      
      statusBox.textContent = 'Cashed out: ×' + formatNumber(live) + ' → +' + formatNumber(win);
      balanceBox.textContent = String(Math.round(userObj.balance*100)/100);
      updateBetUI(); // Update UI to 'Bet' immediately
    }
  });

  // utility to deduct stake from user at flight start
  function deductForActive(amt){
    accounts = loadAccounts();
    accounts[currentUser].balance = Number(accounts[currentUser].balance) - amt;
    saveAccounts(accounts);
    userObj = accounts[currentUser];
    balanceBox.textContent = String(Math.round(userObj.balance*100)/100);
  }

  let lastRoundIndex = null;
  let wasFlightLastTick = false; // State variable to track phase change

  // ********** Main loop controlling rounds **********
  function mainTick(){
    const info = getCurrentRoundInfo();
    const idx = info.roundIndex;
    genIndex.textContent = idx + 1; // human 1..250

    // ************* CRITICAL FIX: Immediate Burst Detection *************
    // This checks for the transition from 'flight' to 'ended' in the same round.
    if(wasFlightLastTick && info.phase !== 'flight'){
        if(activeBet){
            // The round just burst (or ended), and the user didn't cash out. Bet is lost.
            const burstMult = MULTIPLIERS[idx]; // Use the current round's multiplier
            const lostAmount = activeBet.amount;
            activeBet = null; // Clear active bet immediately
            statusBox.textContent = 'Flew off at ×' + formatNumber(burstMult) + '. Bet lost: ' + formatNumber(lostAmount);
            // This update is essential to change the Cash Out button to Bet immediately
            updateBetUI(); 
        }
    }
    wasFlightLastTick = (info.phase === 'flight');
    // *******************************************************************
    
    // update past list rendering
    renderPast();


    // ************* UI UPDATES *************
    if(info.phase === 'pre'){
      roundStateMsg.textContent = 'Betting — Draw in'; 
      roundTimer.textContent = Math.ceil(info.phaseRemaining/1000) + 's';
      liveMultiplierEl.textContent = '×1.00';
      countdownBox.style.display = 'block'; 
    } else { // info.phase === 'flight' or 'ended'
      countdownBox.style.display = 'none'; 
      
      if(info.phase === 'flight') {
        roundStateMsg.textContent = 'Flight — live';
        roundTimer.textContent = (info.FLIGHT_ACTUAL / 1000).toFixed(2) + 's'; 
        const live = getLiveMultiplier(info.phase, info.phaseElapsed, info.generated, info.FLIGHT_ACTUAL);
        liveMultiplierEl.textContent = '×' + formatNumber(live);
      } else { // info.phase === 'ended'
        roundStateMsg.textContent = 'Waiting...';
        // Display the actual burst multiplier for the *previous* round until index changes
        // For the *current* tick, use the burst point of the round that just ended.
        // NOTE: Since the index hasn't changed yet, info.generated is the burst point.
        liveMultiplierEl.textContent = '×' + formatNumber(info.generated); 
      }
    }
    // ********************************************************


    // phase transitions
    if(lastRoundIndex === null) lastRoundIndex = idx;

    // if a new round started (index changed), then handle end-of-previous-round logic
    if(idx !== lastRoundIndex){
      // previous round ended -> its generated multiplier is MULTIPLIERS[lastRoundIndex]
      const prevGen = MULTIPLIERS[lastRoundIndex];
      pushPast(prevGen);
      
      // Active bet was already cleared in the immediate burst detection above, 
      // but in case of a very long wait phase, this clears it before the next round begins.
      // activeBet = null; // Removed: Handled by immediate burst logic above

      // queued bets remain queued for next rounds (they will become active at flight start)
    }

    // Now: if we are just going from PRE_ROUND to FLIGHT and there is queuedBet, make it active and deduct
    // We'll detect when phase is 'flight' and we have queuedBet -> make active if not already active
    if(info.phase === 'flight'){
      if(queuedBet && !activeBet){
        // make it active for this round
        activeBet = { amount: queuedBet.amount, roundIndex: idx };
        queuedBet = null;
        // deduct immediately
        if(currentUser){
          deductForActive(activeBet.amount);
          statusBox.textContent = 'Bet active — good luck';
        } else {
          // if no user session, cancel
          activeBet = null;
          statusBox.textContent = 'No session — bet cancelled';
        }
      }
    }

    // Update bet UI
    updateBetUI();

    // update lastRoundIndex
    lastRoundIndex = idx;
  }

  // run mainTick every 120ms for responsiveness
  setInterval(mainTick, 120);

  // ********** Canvas: plane animation **********
  // REMOVED PLANE ANIMATION: Deleted drawPlane and animLoop entirely.

  // ********** UI actions **********
  withdrawBtn.addEventListener('click', ()=>{ alert('Withdrawal clicked (dummy). GitHub will log the click.'); });
  depositBtn.addEventListener('click', ()=>{
    if(!currentUser){ openAuth('login'); return; }
    const amt = Number(prompt('Enter amount to deposit ():', '0')) || 0;
    if(amt===0) return;
    accounts = loadAccounts();
    accounts[currentUser].balance = Number(accounts[currentUser].balance) + amt;
    saveAccounts(accounts);
    userObj = accounts[currentUser];
    balanceBox.textContent = String(Math.round(userObj.balance*100)/100);
    statusBox.textContent = 'Deposited ' + amt;
  });

  maxBtn.addEventListener('click', ()=>{
    if(!currentUser){ openAuth('login'); return; }
    accounts = loadAccounts();
    const bal = accounts[currentUser].balance || DEFAULT_BALANCE;
    stakeInput.value = bal;
  });
  plus10.addEventListener('click', ()=>{ stakeInput.value = safeNum(stakeInput.value) + 10; });
  plus50.addEventListener('click', ()=>{ stakeInput.value = safeNum(stakeInput.value) + 50; });

  // update displayed bet amount when stake changes
  stakeInput.addEventListener('input', ()=>{ betAmount.textContent = queuedBet ? formatNumber(queuedBet.amount) : (activeBet? formatNumber(activeBet.amount) : formatNumber(safeNum(stakeInput.value))); });

  // ********** initialization **********
  function init(){
    accounts = loadAccounts();
    past = loadPast();
    refreshSession();
    renderPast();
    loading.style.display='none';
    app.style.display='flex';
    // set initial UI
    updateBetUI();
  }
  init();

  // onbeforeunload -> require login again if they close tab? User wants to re-login when visiting other apps.
  // We'll preserve session but require login if they explicitly log out. The user asked: "Ask to log in again if someone Log out Visit other apps Visit other links" — we can't detect app switching; but leaving page and returning keeps session. If they want always re-login we could clear session on visibilitychange hidden; but that would be annoying. We'll clear session on pagehide to match their note that visiting other apps should ask login.
  window.addEventListener('pagehide', ()=>{ /* intentionally do nothing to preserve session */ });
  // To mimic "ask to log in again if visit other apps" we clear session on visibilitychange when hidden (user leaves tab/app)
  document.addEventListener('visibilitychange', ()=>{
    if(document.hidden){
      // clear session to force login on return
      // NOTE: this mirrors user's requirement to re-login when visiting other apps/links
      // BUT if you prefer persistent session, comment next line out.
      clearSession();
      refreshSession();
      statusBox.textContent = 'Session cleared while away; please login again.';
      updateBetUI(); // Ensure bet button reflects logout
    }
  });

  // persist past 10 on start (if empty fill with first few)
  if(!past || past.length===0){
    // fill with first 6 multipliers for display
    for(let i=0;i<6;i++) pushPast(MULTIPLIERS[(TOTAL - 1 - i + TOTAL) % TOTAL]);
  }

  // quick safety: keep UI updated if account changes
  window.setInterval(()=>{ accounts = loadAccounts(); if(currentUser) { userObj = accounts[currentUser]; if(userObj) balanceBox.textContent = String(Math.round(userObj.balance*100)/100); } }, 2000);

  // expose small debug on console
  console.log('Aviator demo initialized. Rounds every ' + (PRE_ROUND/1000) + 's betting phase. Flight time is now variable based on multiplier: FLIGHT = ln(M) * ' + BASE_RATE_MS + 'ms.');

})();
</script>
</body>
</html>
